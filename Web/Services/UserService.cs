using System.Linq;
using Microsoft.EntityFrameworkCore;
using Microsoft.AspNetCore.Identity;
using Npgsql;
using Microsoft.Extensions.Logging;
using Web.Data;
using Web.Models;

namespace Web.Services;

public class UserService
{
    private readonly ApplicationDbContext _context;
    private readonly ILogger<UserService> _logger;

    public UserService(ApplicationDbContext context, ILogger<UserService> logger)
    {
        _context = context;
        _logger = logger;
    }

    public async Task<User> CreateLocalUserAsync(string email, string password, string? fullName)
    {
        if (string.IsNullOrWhiteSpace(email)) throw new ArgumentException("Email is required.", nameof(email));
        if (string.IsNullOrWhiteSpace(password)) throw new ArgumentException("Password is required.", nameof(password));

        var normalizedEmail = email.Trim();
        var now = DateTimeOffset.UtcNow;
        var user = new User
        {
            // Id will be auto-generated by database
            FullName = string.IsNullOrWhiteSpace(fullName) ? null : fullName.Trim(),
            Email = normalizedEmail,
            AuthProvider = "local",
            EmailVerified = false,
            IsActive = true,
            CreatedAt = now,
            LastLoginAt = now
        };

        // Hash the password using ASP.NET Core's built-in password hasher (PBKDF2-based).
        var hasher = new PasswordHasher<User>();
        user.PasswordHash = hasher.HashPassword(user, password);

        try
        {
            // Avoid a pre-check SELECT: some deployments enforce restrictive SELECT/RLS policies.
            // Instead, rely on the unique index on email and translate unique-violation into a friendly message.
            _context.Users.Add(user);
            await _context.SaveChangesAsync();
            return user;
        }
        catch (DbUpdateException ex) when (ex.InnerException is PostgresException pgEx)
        {
            // 23505 = unique_violation
            if (string.Equals(pgEx.SqlState, PostgresErrorCodes.UniqueViolation, StringComparison.Ordinal))
            {
                // Best-effort mapping: constraint names vary across environments.
                if ((pgEx.ConstraintName?.Contains("email", StringComparison.OrdinalIgnoreCase) ?? false) ||
                    (pgEx.Detail?.Contains("email", StringComparison.OrdinalIgnoreCase) ?? false))
                {
                    throw new InvalidOperationException("A user with this email already exists.", ex);
                }
            }

            throw;
        }
    }

    public async Task<User> UpsertGoogleUserAsync(string googleSub, string email, string? name)
    {
        var now = DateTimeOffset.UtcNow;
        User? user = null;

        try
        {
            // Optimize: Try to find by google_sub OR email in a single query (faster than 2 separate queries)
            // Use AsNoTracking for read-only query, then attach if we need to update
            user = await _context.Users
                .AsNoTracking() // Read-only query
                .FirstOrDefaultAsync(u => u.GoogleSub == googleSub || u.Email == email);

            if (user != null)
            {
                // Attach the user to the context for update (since we used AsNoTracking)
                _context.Users.Attach(user);
                _context.Entry(user).State = Microsoft.EntityFrameworkCore.EntityState.Modified;
                
                // Update user with Google info
                if (user.GoogleSub != googleSub)
                {
                    // User exists by email but doesn't have GoogleSub - link it
                    user.GoogleSub = googleSub;
                    user.AuthProvider = "google";
                }
                user.EmailVerified = true;
                user.LastLoginAt = now;
                if (string.IsNullOrEmpty(user.FullName) && !string.IsNullOrEmpty(name))
                {
                    user.FullName = name;
                }
                await _context.SaveChangesAsync();
                return user;
            }

            // Create new user (Id will be auto-generated)
            user = new User
            {
                FullName = name,
                Email = email,
                GoogleSub = googleSub,
                AuthProvider = "google",
                EmailVerified = true,
                IsActive = true,
                CreatedAt = now,
                LastLoginAt = now
            };

            _context.Users.Add(user);
            await _context.SaveChangesAsync();

            return user;
        }
        catch (Exception ex)
        {
            // Log and rethrow to see the actual error
            throw new Exception($"Database error in UpsertGoogleUserAsync: {ex.Message}", ex);
        }
    }

    public async Task<bool> CreateGoogleUserIfNotExistsAsync(string googleSub, string email, string? name)
    {
        if (string.IsNullOrWhiteSpace(googleSub)) throw new ArgumentException("googleSub is required.", nameof(googleSub));
        if (string.IsNullOrWhiteSpace(email)) throw new ArgumentException("email is required.", nameof(email));

        var now = DateTimeOffset.UtcNow;
        var user = new User
        {
            // Id will be auto-generated by database
            FullName = string.IsNullOrWhiteSpace(name) ? null : name.Trim(),
            Email = email.Trim(),
            GoogleSub = googleSub.Trim(),
            AuthProvider = "google",
            EmailVerified = true,
            IsActive = true,
            CreatedAt = now,
            LastLoginAt = now
        };

        try
        {
            _context.Users.Add(user);
            await _context.SaveChangesAsync();
            return true;
        }
        catch (DbUpdateException ex) when (ex.InnerException is PostgresException pgEx)
        {
            // 23505 = unique_violation (email/google_sub already exists)
            if (string.Equals(pgEx.SqlState, PostgresErrorCodes.UniqueViolation, StringComparison.Ordinal))
            {
                return false;
            }

            throw;
        }
    }

    public async Task<User?> GetUserByIdAsync(long userId)
    {
        return await _context.Users
            .AsNoTracking() // Read-only query
            .FirstOrDefaultAsync(u => u.Id == userId && u.IsActive);
    }

    public async Task<User?> GetUserByEmailAsync(string email)
    {
        return await _context.Users
            .AsNoTracking() // Read-only query
            .FirstOrDefaultAsync(u => u.Email == email && u.IsActive);
    }

    public async Task UpdateLastLoginAsync(User user)
    {
        if (user == null) throw new ArgumentNullException(nameof(user));
        user.LastLoginAt = DateTimeOffset.UtcNow;
        await _context.SaveChangesAsync();
    }

    /// <summary>
    /// Best-effort metadata update after a successful login.
    /// This should never prevent the user from signing in (e.g., when UPDATE is blocked by RLS/policies).
    /// </summary>
    public async Task TryUpdateLoginMetadataAsync(User user, string? newPasswordHash = null)
    {
        if (user == null) throw new ArgumentNullException(nameof(user));

        var priorLastLogin = user.LastLoginAt;
        var priorPasswordHash = user.PasswordHash;

        user.LastLoginAt = DateTimeOffset.UtcNow;
        if (!string.IsNullOrWhiteSpace(newPasswordHash))
        {
            user.PasswordHash = newPasswordHash;
        }

        try
        {
            await _context.SaveChangesAsync();
        }
        catch (DbUpdateException ex) when (ex.InnerException is PostgresException pgEx)
        {
            // Typical for Supabase when RLS/policies deny UPDATE.
            _logger.LogWarning(
                ex,
                "Failed to persist login metadata (likely DB permission/RLS). SqlState={SqlState}, Constraint={Constraint}",
                pgEx.SqlState,
                pgEx.ConstraintName);

            // Revert in-memory changes so the scoped DbContext doesn't carry failed modifications.
            user.LastLoginAt = priorLastLogin;
            user.PasswordHash = priorPasswordHash;
            _context.Entry(user).State = EntityState.Unchanged;
        }
        catch (Exception ex)
        {
            _logger.LogWarning(ex, "Failed to persist login metadata (non-fatal).");
            user.LastLoginAt = priorLastLogin;
            user.PasswordHash = priorPasswordHash;
            _context.Entry(user).State = EntityState.Unchanged;
        }
    }
}

